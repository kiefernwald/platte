#!/usr/bin/env ruby

require 'thor'
require 'fileutils'
require 'colorize'
require './lib/combinator'
require './lib/platte_module_loader'

# Platte command line tool
class Platte < Thor
  desc 'combine FILE MAIN [MODULE [MODULE ...]]', 'combine FILE from MAIN and MODULES.'
  option :no_beautify, :type => :boolean, :default => false
  def combine(file, main, *modules)
    puts "Loading selected modules...".green
    begin
      main_module, platte_modules = get_modules main, modules
      output_module_info(file, main_module, platte_modules)
      write_to_file file, Combinator.new.combine(main_module, platte_modules, beautify: !options[:no_beautify])
      puts "Copying assets...".green
      copy_assets File.dirname(file), main_module, platte_modules
      puts "Done.".green
      puts "üè¢"
    rescue PlatteModuleCreationException => e
      puts "Could not load modules to construct #{file}!".black.on_red
      puts "  #{e.reason}".red
    rescue Exception => e
      puts "Could not construct #{file}!".black.on_red
      puts "  #{e.reason}".red
    end
  end

  private

  def output_module_info(file, main_module, platte_modules)
    puts "#{'üèó  Constructing'.green} #{file.yellow} #{'from the following modules:'.green}"
    puts "  * #{main_module.name} (main module) ‚Äì #{main_module.description}".blue
    platte_modules.each { |mod| puts "  * #{mod.name} ‚Äì #{mod.description}".blue }
  end

  def get_modules(main, modules)
    loader = PlatteModuleLoader.new
    main_module = loader.create_from_folder "modules/%s.main" % main
    platte_modules = modules.map { |mod| loader.create_from_folder "modules/%s.module" % mod }

    [main_module, platte_modules]
  end

  def write_to_file(file, contents)
    file = File.new(file, "w")
    file.write(contents)
    file.close
  end

  def copy_assets(destination, main, modules)
    FileUtils.copy_entry "#{main.directory}/assets", "#{destination}/assets"
    modules.each { |mod| FileUtils.copy_entry "#{mod.directory}/assets", "#{destination}/assets" } if modules
  end
end

Platte.start
